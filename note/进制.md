# **进制**

 - 基本介绍: 整数四种表达方式:

> 二进制: 0,1; 满2进1; 以`0b`或`0B`开头
> 十进制: 0-9; 满10进1.
> 八进制: 0-7; 满8进1, 以数字`0`开头
> 十六进制: 0-9, 以及A(10)到F(15). 满16进1, 以`0x`或`0X`开头表示, A-F不区分大小写

```java
//十进制:
int n1 = 11
//十六进制
int n2: 0xB
//八进制
int n3 = 013
//二进制
int n4 = 0b1011
```

#### 转成十进制

***

###### 二进制转十进制:

 - **从最低位(右边)开始, 将每个位上的数提取出来, 乘以2的(位数-1)次方, 然后求和**
    `0b1011`
    $$ 0b1011 = 1*2^{1-1}+1*2^{2-1}+0*2^{3-1}+1*2{4-1} = 1+2+0+8 = 11 $$

###### 八进制转十进制

 - **从最低位(右边)开始, 将每个位上的数提取出来, 乘以8的(位数-1)次方, 然后求和**
    `0234`
    $$ 0234 = 4*8^0 +3*8^1+2*8^2=4+24+128=156 $$

###### 十六进制转十进制

`0x23A`

 - **从最低位(右边)开始, 将每个位上的数提取出来, 乘以16的(位数-1)次方, 然后求和**
    $$ 0x23A = 10*16^0+3 * 16 ^ 1 + 2 * 16^2 = 10 + 48 + 512 = 570 $$

***

#### 十进制转其他进制

***

###### 十进制转二进制

 - 规则:  
    - **将该数不断的除以2, 直到商为0.**
    - **之后把每步得到的余数倒过来, 就是对应的二进制数**
 - 具体案例: 把 34 转换成二进制
    - ![10](/Users/wangrundong/Documents/GitHub/Java_study_blog/note/pic/10.jpg)
    - $34/2 = 17, 余0$
    - $17/2 = 8, 余1$
    - $8/2=4, 余0$
    - $4/2=2, 余0$
    - $2/2=1, 余0$
 - 把所有的数倒着看, 放在一起, 就成了: 
 - `0b100010`


###### 十进制转八进制

 - 规则:
    - **将该数不断除以8，直到商为 0 为止．**
    - **然后将每步得到的余数倒过来，就是对应的八进制**
 - 具体案例：把131转成八进制
    - 具体做法同上
    - $131/8=16, 余3$
    - $16/8=2, 余0$
    - $2/8, 没法做$
 - 把所有的数倒着看, 放在一起, 就成了: 
    - 0203



###### 十进制转十六进制

 - 规则
    - **将该数不断除以 16，直到商为 0 为止.**
    - **然后将每步得到的余数倒过来，就是对应的十六进制。**
 - 具体案例: 把237转换成十六进制
    - 具体做法同上. 
    - $237/16=14,余13$


###### 二进制转换成八进制

 - 规则: 
    - **从低位开始,将二进制数每三位一组，转成对应的八进制数即可**
 - 具体案例: 把0b11010101转换成八进制
    - ob11(3)010(2)101(5) => 0325

###### 二进制转换成十六进制

 - 规则: 
    - **从低位开始，将二进制数每四位一组，转成对应的十六进制数即可**
 - 具体案例: 把0b11010101转换成十六进制
    - 0b1101(D)0101(5) = 0xD5

###### 八进制数转换成二进制

 - 规则: 
    - **将八进制数每 1 位，转成对应的一个 3 位的二进制数即可**
 - 具体案例: 0237 转换成二进制
    - 02(010)3(011)7(111) = 0b10011111

###### 十六进制数转换成二进制

 - 规则: 
    - **将十六进制数每 1 位，转成对应的 4 位的一个二进制数即可**
 - 具体案例: 把0x23B转换成二进制
    - 0x2(0010)3(0011)B(1011) = 0b1000111011


##  位运算

### 二进制再运算中的说明

1. 二进制是风二进位的进位制, 0,1是基本算符
2. 现代计算机技术全部采用的是二进制, 因为它只是要0,1两个数字符号, 非常方便简单. 计算机内部数据信息都是采用二进制数来表示的

### **_原码, 反码, 补码_**

 - 对于有符号的而言:

1. 二进制的最高位是符号位; 0表示正数, 1 表示负数.
2. 正数的原码, 反码, 补码都一样
3. 负数的反码 = 它的原码符号位不变, 其他位取反(0->,1->0)
4. 负数的补码= 它的反码+1, 负数的反码= 负数的补码-1
5. 0的反码, 补码都是0
6. java没有无符号数(Java的数都是有符号的)
7. 计算机在运行的时候, 都是以**补码的方式**来运算的
8. 当我们在看运算结果的时候, 要看它的原码

### 位运算符

 - java中由七个位运算符(`&`, `|`, `^`, `~`, `>>`, `<<`, `>>>`)
    - 分别是按位与`&`, 按位或`|`, 按位异或`^`, 按位取反`~`

| 位运算符    | 运算规则                      |
| ----------- | ----------------------------- |
| 按位与`&`   | 两位全为1, 结果位1, 否则为0   |
| 按位或`|`   | 两位有一个为1, 否则全为0      |
| 按位异或`^` | 两位一个为0, 一个为1, 否则为0 |
| 按位取反`~` | 0 ->1, 1->0                   |

> [!NOTE]
> 两个二进制数, 上下进行运算+判断

```java
public class bitoperator {
    public static void main(String[] args) {
        System.out.print(2&3);
        // 1. 首先得到2的补码 => 2的原码为 00000000 00000000 00000000 00000010
        // 因为int存储了4个字节, 所有前面有这么多的0
        //  由此,得到补码: 00000000 00000000 00000000 00000010
        //  因为2是正数, 所以它的原码, 补码, 反码都一样
        // 2. 3的原码: 00000000 00000000 00000000 00000011
        //  同理易证: 3的补码也是00000000 00000000 00000000 00000011
        // 3. 按位与&: 00000000 00000000 00000000 00000010
        //             00000000 00000000 00000000 00000011
        //           = 00000000 00000000 00000000 00000010
        //             因为运算出的数正好是个整数, 运算后的原码也就就是结果

        System.out.print(~-2);// 得数为1
        // 先得到 -2的原码: 10000000 00000000 00000000 00000010
        // 第一位负号位
        // 2. 因为负数的补码是反码+1, 所以先得到反码再说
        // -2反码 = 11111111 11111111 11111111 11111101
        // 3. -2 的补码 = 反码+1
        // 也就是说等于: 11111111 11111111 11111111 11111110
        // ~-2操纵: 00000000 00000000 00000000 000000001这是运算后发补码
        // 运算后因为是整数, 所以答案就是00000000 00000000 00000000 000000001

        System.out.print(~2);
        // 得到2 的补码: 00000000 00000000 00000000 00000010
        // 按位取反: 11111111 11111111 11111111 11111101
        // 运算后看原码: 11111111 11111111 11111111 11111100(也就是-1)
        // 运算后的原码: 10000000 00000000 00000000 00000011 = -3

        System.out.print(2|3);
        // 得到2的补码: 00000000 00000000 00000000 00000010
        // 得到3的补码: 00000000 00000000 00000000 00000011
        // 按位或: 00000000 00000000 00000000 00000010
        //         00000000 00000000 00000000 00000011
        //         00000000 00000000 00000000 00000011 

        System.out.print(2^3);
        // 得到2的补码: 00000000 00000000 00000000 00000010
        // 得到3的补码: 00000000 00000000 00000000 00000011
        // 按位异或:    00000000 00000000 00000000 00000001 = 1
    }
    
}
```

 - 还有三个位运算符: `>>`, `<<`, `>>>`
    - 算数右移`>>`: __低位溢出, 符号位不变, 并用符号位补溢出的高位__
    - 算数左移`<<`: __符号位不变, 低位补0__
    - 逻辑右移`>>>` __ 低位溢出, 高位补0__
    - 没有`<<<`

```java
public class bitoperator02 {
    public static void main(String[] args) {
        int a = 1>>2; // // 1 = 00000000 00000000 00000000 00000001
        // 其本质就是把最后两位的有01和1扔出去, 再用符号位(前两位)来进行补全
        // 进行运算后: a = 00000000 00000000 00000000 00000000 = 0
        // 也就是说: 1/2/2

        int b = 1<<2; // 00000001 = 1
        // 本质就是1*2*2, 也就是说: 00000100
        System.out.print(a);
        System.out.print(b);

        System.out.print(2<<8); // 512 = 2 * 2^8
    }
}
```
